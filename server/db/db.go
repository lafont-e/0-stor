/*
 * Copyright (C) 2017-2018 GIG Technology NV and Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package db

import (
	"context"
	"errors"
)

// Constant DB errors
var (
	ErrNotFound   = errors.New("key not found")
	ErrNilKey     = errors.New("nil-key not allowed")
	ErrClosedItem = errors.New("item is already closed")
	ErrConflict   = errors.New("update conflicted, try again")
)

// UpdateCallback is the type of callback to be used,
// when wanting to update (race-condition free) an item in a database.
type UpdateCallback func(origData []byte) (newData []byte, err error)

// DB interface is the interface defining how to interact with the key value store.
// DB is threadsafe
type DB interface {
	// Set stores data in a database, linked to the given key.
	Set(key, data []byte) error

	// SetScoped stores data in a database, within a given scope, defined by the scope key.
	// The actual storage key to be used and stored within that server,
	// is generated by the database implementation, and returned when the data was stored successfully.
	//
	// The returned key is to be used for all other actions that relate to the stored data.
	//
	// It is guaranteed that the given ScopeKey is also the prefix of the returned key.
	// On the exact detail beyond this information can however not be relied,
	// as this is up to the database implementation.
	//
	// There is no protection against key overwrites using the normal Set function.
	// Therefore you should ensure to not use the same keys for both
	// SetScoped and Set.
	SetScoped(scopeKey, data []byte) (key []byte, err error)

	// Get fetches data from a database mapped to the given key.
	// The returned data is allocated memory that can be used
	// and stored by the callee.
	Get(key []byte) ([]byte, error)

	// Exists checks if data exists in a database for the given key.
	// and returns true as the first return parameter if so.
	Exists(key []byte) (bool, error)

	// Delete deletes data from a database mapped to the given key.
	Delete(key []byte) error

	// ListItems lists all available key-value pairs,
	// which key equals or starts with the given prefix.
	// The items are returned over the returned channel.
	// The returned channel remains open until all items are returned,
	// or until the given context is done.
	// Each returned Item _has_ to be closed,
	// the channel won't receive a new Item until the previous returned Item has been Closed!
	// The prefix is optional, and all items will be returned if no prefix is given.
	//
	// NOTE:
	// it is not guaranteed that all items returned are from the same generation
	// as when the ListItems was called. Meaning that some keys might be updated,
	// in-between the time this function is called and the item is returned.
	// Or if the key was deleted, one key that existed when this function was called,
	// might not be returned at all.
	ListItems(ctx context.Context, prefix []byte) (<-chan Item, error)

	// Close the DB connection and any other resources.
	Close() error
}

// Item is returned during iteration. Both the Key() and Value() output
// is only valid until Close is called.
// Every returned item has to be closed.
type Item interface {
	// Key returns the key.
	// Key is only valid as long as item is valid.
	// If you need to use it outside its validity, please copy it.
	Key() []byte

	// Value retrieves the value of the item.
	// The returned value is only valid as long as item is valid,
	// So, if you need to use it outside, please parse or copy it.
	Value() ([]byte, error)

	// Error retrieves the error,
	// which occurred while trying to fetch this item.
	Error() error

	// Close this item, freeing up its resources,
	// and making it invalid for further use.
	Close() error
}

// ErrorItem is an Item implementation,
// which can be used for returned items,
// that couldn't be fetched due to an error.
type ErrorItem struct {
	Err error
}

// Key implements Item.Key
func (item *ErrorItem) Key() []byte { return nil }

// Value implements Item.Value
func (item *ErrorItem) Value() ([]byte, error) { return nil, item.Err }

// Error implements Item.Error
func (item *ErrorItem) Error() error { return item.Err }

// Close implements Item.Close
func (item *ErrorItem) Close() error { return item.Err }

// CountKeys counts the (filtered) keys found for the given Database.
func CountKeys(db DB, prefix []byte) (int, error) {
	if db == nil {
		panic("no database given to count keys on")
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	ch, err := db.ListItems(ctx, prefix)
	if err != nil {
		return 0, err
	}

	var count int
	for item := range ch {
		count++
		err = item.Close()
		if err != nil {
			return 0, err
		}
	}
	return count, nil
}

var (
	_ Item = (*ErrorItem)(nil)
)
